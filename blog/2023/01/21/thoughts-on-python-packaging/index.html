<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Thoughts on the Python packaging ecosystem | Pradyun Gedam</title><meta name=keywords content="Python Packaging"><meta name=description content="My response to the discussion topic posed in Python Packaging Strategy Discussion Part 1 had become quite long, so I decided to move it to write a blog post instead. This post then started absorbing various draft posts I&rsquo;ve had on this topic since this blog was started, morphing to include my broader thoughts on where we are today.
Note: I&rsquo;ve updated this to cover an aspect of the recent LWN article on the topic as well."><meta name=author content><link rel=canonical href=https://pradyunsg.me/blog/2023/01/21/thoughts-on-python-packaging/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ce635198c070aa2b504b38728fe282d3ce5b5f9d525d05aead99754184ac740e.css integrity="sha256-zmNRmMBwqitQSzhyj+KC085bX51SXQWurZl1QYSsdA4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://pradyunsg.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pradyunsg.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pradyunsg.me/favicon-32x32.png><link rel=apple-touch-icon href=https://pradyunsg.me/apple-touch-icon.png><link rel=mask-icon href=https://pradyunsg.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.109.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Thoughts on the Python packaging ecosystem"><meta property="og:description" content="My response to the discussion topic posed in Python Packaging Strategy Discussion Part 1 had become quite long, so I decided to move it to write a blog post instead. This post then started absorbing various draft posts I&rsquo;ve had on this topic since this blog was started, morphing to include my broader thoughts on where we are today.
Note: I&rsquo;ve updated this to cover an aspect of the recent LWN article on the topic as well."><meta property="og:type" content="article"><meta property="og:url" content="https://pradyunsg.me/blog/2023/01/21/thoughts-on-python-packaging/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-01-21T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-21T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Thoughts on the Python packaging ecosystem"><meta name=twitter:description content="My response to the discussion topic posed in Python Packaging Strategy Discussion Part 1 had become quite long, so I decided to move it to write a blog post instead. This post then started absorbing various draft posts I&rsquo;ve had on this topic since this blog was started, morphing to include my broader thoughts on where we are today.
Note: I&rsquo;ve updated this to cover an aspect of the recent LWN article on the topic as well."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Scribbled Notes","item":"https://pradyunsg.me/blog/"},{"@type":"ListItem","position":2,"name":"Thoughts on the Python packaging ecosystem","item":"https://pradyunsg.me/blog/2023/01/21/thoughts-on-python-packaging/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Thoughts on the Python packaging ecosystem","name":"Thoughts on the Python packaging ecosystem","description":"My response to the discussion topic posed in Python Packaging Strategy Discussion Part 1 had become quite long, so I decided to move it to write a blog post instead. This post then started absorbing various draft posts I\u0026rsquo;ve had on this topic since this blog was started, morphing to include my broader thoughts on where we are today.\nNote: I\u0026rsquo;ve updated this to cover an aspect of the recent LWN article on the topic as well.","keywords":["Python Packaging"],"articleBody":"My response to the discussion topic posed in Python Packaging Strategy Discussion Part 1 had become quite long, so I decided to move it to write a blog post instead. This post then started absorbing various draft posts I’ve had on this topic since this blog was started, morphing to include my broader thoughts on where we are today.\nNote: I’ve updated this to cover an aspect of the recent LWN article on the topic as well.\nTL;DR This post is a bit long, so here’s the key points I’m making:\nThe Python packaging ecosystem unintentionally became the type of competitive space that it is today. The community needs to make an explicit decision if it should continue operating under the model that led to status quo. Pick from N different tools that do N different things is a good model. Pick from N ~equivalent choices is a really bad user experience. Picking a default doesn’t make other approaches illegal. Communication about the Python packaging ecosystem is fragmented, and we should improve that. My experience around Python Packaging At the time of writing:\nI’m a maintainer on pip, installer, resolvelib, packaging, flit, Spack (allegedly), sphinx-theme-builder, pyproject-hooks, and more. I’m a moderator on PyPI. I’ve contributed in varying manners to setuptools, wheel, warehouse (i.e. PyPI), pipenv, Poetry, packaging.python.org, build, and more. As a maintainer on pip, I’m a member of the Python Packaging Authority (PyPA). I’ve co-authored multiple Packaging PEPs, including the PyPA’s Governance Model. I’ve been the PEP-Delegate on multiple Packaging PEPs, trusted to make decisions on behalf of the community. Python users are not software engineers Many of the users who write Python code are not primarily full-time software engineers or “developers”. They are not particularly interested in this aspect of their job. They’re using Python as a tool to get their job done. They’re not interested in the details of how the tool works, or even how complicated things are under the hood.\nAs Thea (Stargirl) Flowers said recently:\nThe reason there are so many tools for managing Python dependencies is because Python is not a monoculture and different folks need different things.\nUser expectations for a “default” workflow A class of users expect a packaging tool that provides a cohesive experience (like npm (NodeJS), cargo (Rust), gem (Ruby), pub (Dart), dotnet (C#/.NET), etc) – a single tool that provides a build system, dependency manager, publishing, running project-specific tasks/scripts, etc. I’ve referred to this as “workflow tool” in this post.\nCertain other ecosystems have this in their “default” tool, providing a much more streamlined experience for users. I have first hand experience of this for NodeJS and Rust, where they have a single tool that users invoke to do the majority of their work:\ncreate a new project. install/manage dependencies. run their project w/ those dependencies. test their project. publish their project. more?! Today, each of these pieces is a separate tool for Python and doesn’t have a strict 1:1 mapping to the “best practices”/“secure” workflows. This is at odds with the expectations that these users have. This class of users, by and large, want consolidation and a single-tool experience.\nWe know that this class of users exists because we have:\na number of popular tools that are attempting to provide this experience. results from user surveys we’ve done1 clearly indicate this as well. had multiple community members say this in multiple ways, across multiple channels. Flexibility leads to complexity Brian Skinn said recently:\nYou can package darn near anything in Python, even though it may take figuring out a complicated three-step-and-a-hop process to get there… and I suspect that this has been part of what’s enabled Python to grow into its “second best programming language for every task” aphorism.\nI think there’s some truth to that. “An Overview of Packaging for Python” on packaging.python.org expresses a similar tone as well:\nPackaging in Python has a bit of a reputation for being a bumpy ride. This impression is mostly a byproduct of Python’s versatility.\nI do want to contrast this with the fact that the overview page takes over 3000 words, to provide the “high-level” overview for how one can approach packaging a Python project. It doesn’t even touch the specifics of configuration or provide any specific workflow guidance with that much digital ink.\nThe bumpy ride reputation is not misplaced, and is the most frequent user complaint (more on this later). There are consequences to the degree of flexibility afforded to users by the Python packaging ecosystem:\nevery Python project has to make multiple decisions about how they want to do certain things every Python user has to make choices for how they wanna manage their Python installation and workflow tools it leads to multiple ways to achieve the same thing when trying to use Python packaging tools, with some of these ways being subtly wrong it leads to a larger surface area of behaviours of existing/established tools that users rely upon. it makes it much more likely that new users hit edge cases and paper-cuts, that more-experienced developers won’t hit because they have adapted their workflow to avoid certain failure modes over time. The flexibility is great to have when you need it but, without a “default” workflow, it serves to create more user confusion than it resolves. It contributes to the bumpy ride reputation and to the perceived complexity.\nPlacing the Python packaging ecosystem on the community spectrum When I was reading “The community spectrum: caring to combative” - Insight From Alex Bayley on Sumana Harihareswara’s blog, it flagged something amusing to me. I recommend reading the article, but I’ll quote a portion that provides sufficient context for the rest of this post.\nThe Competitive Spectrum describes communities as being:\nCaring: members are motivated by helping each other. Collaborative: members share goals and help each other to achieve them. Cordial: members have their own goals which do not conflict with each other. Competitive: members share the same goals, and compete against each other to achieve them. Combative: members must achieve their goals by preventing others from being doing so. PyPA and Conda Within this spectrum, I think the relationship between Conda and PyPA projects is definitely collaborative.\nThe two groups of maintainers have worked together to solve problems that affect both groups. Conda packages are often built up from Python packages that are built with PyPA tools. Heck, at the time of writing, one of the founders of the PyPA currently sits on the Conda Steering Council.\nPython build-backends The goal of enabling pyproject.toml-based builds2 was to move Python packaging from a collaborative (or at least, cordial) model, to a competitive model for the build mechanisms.\nThe stated goal of PEP 517 is:\nThe goal of this PEP is get distutils-sig out of the business of being a gatekeeper for Python build systems. If you want to use distutils, great; if you want to use something else, then that should be easy to do using standardized methods.\nMoving to a competitive model for build mechanisms was intended to enable the ecosystem to move away from the “only one way” of building Python packages (the quote is from the Zen of Python) because the implementation we had of “only one way” was exceedingly difficult to evolve.\nPoetry / PDM / Hatch / PyFlow / etc These tools are firmly in a competitive model. They’re competing for users. They’re competing to be the “best” solution to the “workflow” problem. They’re, arguably, even competing for contributors.\nOther than the obvious sign that these tools can’t be used together on the same codebase (mostly), this can be seen in other aspects of these projects:\nthe way they’re marketed/documented – they have an incentive to invest in this, because they’re competing for users and good-looking/flashy documentation is a good way to attract users. the way they do community management: some have dedicated community Discord servers, mention $tool-specific ecosystems, have their own $tool plugin ecosystems, etc. the way their users advocate for them as the one-true-solution on the internet :) This competition also leads to incentives for projects to do things like implementing draft standards that are not accepted or settled and claims that standards are implemented, even when the implementation does not match the standard.\nUnintended competition In my opinion, ending up with multiple competing workflow tools in the Python ecosystem was not an intentional choice by any individual or group.\nWhile providing alternatives to distutils/setuptools was the intent of pyproject.toml-based build systems, I don’t think it was intended nor was there ever consensus that we wanted to end up with an ecosystem of competing tools which use the pyproject.toml-based build system and provide an end-to-end workflow.\nI don’t see any discussion of such tooling in the corresponding mailing list discussions and the PEPs certainly don’t talk about trying to enable building alternative workflow-related tooling. There’s extensive discussion about the technical design of the final solution and on many aspects of “how to build distribution files”, but there’s no discussion about how competing workflow tools would be enabled.\nAnother reason is… well… let’s dig into some “history”. The Python Packaging Authority has publicly written goals for them:\nAlthough it’s still being defined, to work towards a “Meta-Packaging” system that: Clearly delineates the phases of distribution Allows for multiple interacting tools vs one monolithic tool Specifically allows for alternative build systems, i.e. a “MetaBuild” system. These goals were written in a different “era” of Python packaging, before PEP 516/517/518 were being debated, when the ecosystem was still in an entirely collaborative/cordial model (on the other side of a combative era3), and when the “Python ecosystem” was much smaller than it is today4.5\nThe intent was to enable the ecosystem to build multiple tools that interacted with each other and allow for alternative build tooling to solve problems that were difficult to solve with distutils/setuptools.\nA competitive ecosystem for workflow tooling is an unintended consequence of the pyproject.toml-based build system. The PyPA’s focus on standardisation made it easier to build workflow tooling that interacted with other packages, with no mechanisms to check whether these tools are reciprocating on interoperability.\nOn existing workflow tools I expect the most relevant people already know this, but I’ll state it explicitly: I have a lot of respect for the work done by the authors and/or maintainers of tooling like Poetry, PDM, Hatch, Pipenv, PyFlow, etc. I think they each, individually, contribute meaningfully and positively to the ecosystem.\nThe most popular workflow tools for Python handle the underlying details for the user and give them a single unified tool that has install / publish / run commands. They also provide functionality that the “default” tools do not (eg: environment-agnostic lockfiles, automated environment management etc). Serving as an end-to-end tool enables them to trim the scope and define it as they deem appropriate.\nConda also does this to a certain extent, by tying the environment management and package management together into a single tool, but it also operates on a different level than these tools – packaging “everything” rather than just Python packages.\nThe reasons for the existence of workflow tools Some/all of the “workflow tools” that exist today because the “default” tooling did not cover more of the user’s workflow with a single piece.\nPipenv’s Pipfile was created with the express goal of being for pip6. Poetry was created to provide a single config file with a single tool experience, and a better dependency resolution model. Hatch was created as “a productivity tool designed to make your workflow easier and more efficient, while also reducing the number of other tools you need to know.”. PDM was created as a “Python package manager with PEP 582 support” (which is notable, given that PDM does not implement PEP 582). These tools have all now dropped that language from their documentation (or at least evolved it) to reflect that they’re now focused on providing a complete and unified experience for the user. This can be seen by the fact that they’ve all gone ahead and invented their own build-backends (except Pipenv, which is maintaining a fork of pip within it), since providing a complete and unified experience requires that the tool also controls how projects are built.\nNow, to state the obvious, the folks who created these tools are not fools who like to create work for themselves or enjoy reinventing the wheel. They created because they felt that the existing tooling wasn’t meeting their needs and that there was no clear path to improving the pre-existing tooling to meet those needs. Each of these tools solves the problem by making different calls for what the right trade-offs are.\nI am certain that it is not possible to create a single “workflow” tool for Python software. What we have today, an ecosystem of tooling where each makes different design choices and technical trade-offs, is a part of why Python is as widespread as it is today. This flexibility and availability of choice is, however, both a blessing and a curse. That’s actually a great segue to talk about…\npip: A privileged player Today, pip is uniquely positioned within in the Python packaging ecosystem. It is the only7 piece of the Python packaging tooling that ships with Python, and is guaranteed8 to be installed in every environment. Nearly every Python user9 who wishes to share code (or use shared code) uses it today, directly or indirectly.\nThe fact that I’ve added 3 footnotes in the last paragraph is a symptom of something and I’m not sure if it’s a good thing or a bad thing.\npip: A disadvantaged player This point is easier to make with an example, let’s take lockfiles: it’s technically feasible to implement an arbitrary lockfile format in pip, that evolves with pip, in lock-step with it (something of this sort is implemented already in the form of pip-tools).\nGiven the privileged position that pip has within the ecosystem (i.e. ships with the language), whatever it does would become the de-facto standard and commercial tools/IDEs will add support for that model much quicker (eg: requirements.txt) than something similar from PDM, Poetry, Pipenv etc.\nNow, on the face of it, this is a completely different direction from PyPA’s model of “interoperability standards through concensus” because, effectively, whatever pip implements would become a de-facto standard for what the ecosystem and tooling supports.\nOn the other hand, if we focus on designing for interoperability through concensus before implementing functionality in pip, implementing vital workflow improvements is now blocked on an exhaustingly long process of a non-iterative, waterfall-style design process. Further, an interoperable lockfile format also has to try to satisfy needs to tools that use completely different resolution models even semantically incorrect ones10.\nTaking a slightly iterative approach of “we’ll cover the more complicated case later” caused the last proposal for a lockfile format standard to be rejected after months of discussion.\nWe’re in a state where the process for adding new functionality to our default “out of the box” experience is designed to be both very difficult and very “energy” intensive – leading to it being pretty slow. The reason the default tooling doesn’t improve is that making meaningful improvements to it is blocked on trying to cater to all workflows; in ways that alternative tooling is not.\nThe effect of this is that our “out of the box” experience is always going to be worse than the experience with other tools in the ecosystem. In a competitive ecosystem, is that what we want? Heck, at that point, do we even want to be in a competitive ecosystem?\nOn build-backends tied to workflow tools Hatchling, pdm-backend and poetry-core are all examples of this. Flit/flit-core is another slightly-weaker example of this11. They each have build-backends that are either (a) tied to a particular workflow tool in some way or (b) promoted along with a workflow tool.\nThe build backends are all solving the “build a wheel from Python code” problem, but with different user experiences tacked onto them. Building multiple tools that solve the same problem is duplicated effort.\nPart of the problem here is that these tools (with the exception of PDM) are not built with interoperability in their design, and these tools have basically little to no incentive to take on the complexities of providing interoperability.\nFlit can only be used with flit_core, and flit build doesn’t build the same artifacts as python -m build would.\nHatch is tied to hatchling, and “it would be an extraordinary amount of effort” to support using a different build-backend for your project when using Hatch.12\nPoetry has its own dependency specification format, and the corresponding build-backend enables it to build packages that use that format.\nPDM is better on this front, in that it has greater backend-agnostic behaviours to it. However, pdm-backend is undergoing a rewrite to “provide a similar extensible interface to hatchling”.\nThese were all made possible by the explicit focus of the PyPA on designing an interoperability model – i.e. Unix-like approach – which these tools have used to create tool-specific build-backends. :)\nWhile we trying to enforce that one way of building packages/managing dependencies for all Python users is not feasible… having 4 build-backends that all handle pure-Python packages with the same file holding their configuration, while providing slightly different user experiences is also not a good place to be in IMO.\nPick from N ~equivalent choices is really bad UX When you package Python software, a user has to make a lot of choices. There are a lot, and I do mean a lot, of “A vs B” comparisons that you can make when it comes to figuring out the scaffolding for packaging and distributing Python software.\nThe problem with not making a default recommendation for these largely-inconsequential choices is that it means that every user has to make these choices. Instead of making a choice once and then being able to build upon that as an ecosystem, we keep moving in circles on these topics because we’ve got two groups now and picking either choice means that the other group is unhappy.\nThis also leads to the same problems being solved twice – there’s duplicated effort and duplicated documentation. Each project will design their own approach and there’s incentive for projects to try to “out-compete” each other by providing more features or by providing better documentation, rather than contributing to improving a common corpus.\nThis is how, for example, we end up with packaging.python.org not having a standard structure for declaring metadata that is implemented by ~every build-backend documented, even though there was extensive documentation for the same in multiple tools’ own documentation for months. Each of those tools’ authors have had incentives to document it for their users and it was easier to do so in their own documentation where they don’t have to worry about the concerns of other tools or “being generic enough”.\n“not a PyPA project” The only reason various Python packaging projects (notably, Poetry and PDM) are not PyPA projects is because they’ve never asked to become one.\nAs it stands, the PyPA views itself as a big umbrella. Basically any established Python packaging project that asks to be included, will be accepted. If Poetry and PDM ever asked to join, as it stands, there’s no version of this timeline where the existing PyPA members say no.\nFrom the discussions I’ve had, the reasons have ranged from some sense of maintaining control (which doesn’t really have good precedence), to logistical issues like GitHub Actions queues, as well as a sense of being able to “be successful without the tag”.\nAlso, to say that these tools are “are not participating in the PyPA”13 is incorrect. PDM’s whole pitch today is that it is “A modern Python package and dependency manager supporting the latest PEP standards”. Poetry’s authors somewhat regularly interact with the interoperability discussions and its original author has even co-authored a PEP.\nOn the Python Packaging Authority I think there’s a need to reconsider what the Python Packaging Authority should be trying to do and what it even is. We’ve been cruising on the premise that we’re maintaining foundational tools and designing for interoperability is the “right” model for the Python packaging ecosystem. I’m not sure that’s the case.\nBetween the user surveys, having a $work role where I’m directly influencing user workflows beyond the installer, spending time helping out with scientific Python tooling and with pyOpenSci, and the discussions in the strategy thread… I’m starting to think that our current approach is not working and is harmful14 unintentionally. Each projects’ maintainers effectively decide on different aspects of the the overall UX. Each project acts as its own project. There is no broader guiding “roadmap”. Making decisions about how the default tooling of the ecosystem works is “not appropriate” for our process to hashing out technical design proposals. There is no “blessed” tool and yet there are defaults, things that ship with the Python standard library and PyPA recommendations.\nI’m not sure what the right answer is, but I don’t think we’re in a good place right now. Here’s where we are:\neven co-operating tools are viewed as being in competition with each other interoperability standards that are written but are not enforced on the principle of “consenting adults” or “be permissive in what you accept” for backwards compatibility reasons because “we should trust the XYZ authors to do the right thing” difficult to answer basic questions like “what can a source distribution file be named” because the standard says one thing while the tools do something else because “the author prefers that” implemented and publicized as features in tools, despite not being something that is “accepted” absolutely ignored by tool authors “because it’s not a priority” duplicated effort because multiple tools are competing users are confused about what to use, what is deprecated, what is the “right” way to do things etc and there is no authoritative answer say that PEPs are not documentation but, also, go read this PEP for the details on how this feature works because that’s the only place we wrote it. no clear answer for step 0 questions like where should I put by .py files relative to my pyproject.toml file a lack of willingness to draw a line in the sand and say “this is the way things are done” because “what if someone finds a better way in the future” we don’t pick one of two ~equivalent choices because “they’re both valid workflows” there is no agreed upon direction for the ecosystem We don’t need more “generic” build-backends today With setuptools gaining pyproject.toml configuration support and a standard structure for declaring metadata that is implemented by ~every build-backend, there isn’t a significant difference between the various tools for pure-Python packages.\nThere are only so many ways to construct a .zip file containing a bunch of pure-Python files + metadata. The only real difference is in the user experience, and the user experience is largely determined by the tooling that invokes the build-backend.\nBuilding more build-backends that are intended to be extended (beyond what we already have, between hatchling, pdm-backend and setuptools) feels unnecessary to me; and we might already have one too many options for this.\nOn pip as a workflow tool Donald Stufft has said on pip’s issue tracker:\nAll that being said, I think trying to follow the “unix philosophy” is a mistake and is actually a pretty poor UX. Yea a lot of nerds grok it because we’ve caused enough collective brain damage by being forced to use it over time and it works better for the typical unix tools because they generally just come preinstalled. I think it would just add additional complexity to an already confusing landscape of tools for our end users.\nAnd, Paul Moore has said:\nAt some point, I do think that pip needs to make a firm decision on whether it’s a development workflow tool or just an installer\nAnd, I think that now is the time to make that decision.\nThe recent strategy discussion is sprawling and has largely operated with the assumption that pip is not something that can become a “workflow tool”. I think that’s an incorrect assumption.\nPersonally, I’ve wanted pip to cover more aspects of the user’s workflow since before PEP 517 was implemented, which was around the time I started getting involved in Python15. Improving the “base” tool to cover more use cases is not a bad idea – it’s helpful for most user personas. Outside of blessing another tool, this is the path of least resistance that we can take to getting to a better state.\nDo I think there’s a significant amount of work needed for making pip into a workflow tool?\nYes.\nDo I think that the amount of energy that’s gone into Poetry/Hatch/Pipenv/PDM development, collectively, would have made more than a meaningful dent at this issue?\nYes.\nDo I think that, at this point, blessing another tool is a good idea?\nMaybe. We’ve built a competitive ecosystem, and I don’t think we can just “pick one” of the “new things” and expect that to be the end of it.\nDid we ever have sufficient buy-in + capacity to do this with pip, along with contributor experiences that would facilitate this?\nNo. That’s been a part of the problem – we’ve made it fairly tractable to “build your own” in a sandbox that lets you ignore the need to support entire swaths of workflows, and that’s something you can’t compete with easily for contributor experience. And, when the alternative is “spend a few months trying to implement something in a ’legacy’ codebase, while catering to needs that you don’t have, also convince a bunch of people with limited availability that your idea is a good one and wait for them to review what you wrote”, it’s not surprising that we end up with a bunch of “new things” and have multiple groups building multiple workflow tools.\nWe still don’t have agreement that this is the direction that we, as a community, want pip to go.\nOn user-facing communication There’s no single place where users can go to get information about the Python packaging ecosystem – either on how it’s evolving or what the functional best-practices are today. We either (a) don’t have them documented or (b) don’t have a good approach to communicating about this to end users.\nThere’s a cost to this.\nLWN recently directed readers to a blog post16 that claims that the strategy discussion is evidence that “PyPA must be destroyed”, implies that there’s “ivory towers of packaging tool maintainers”, that “half of the discussion participants did not even bother reading what the people think” based on a misunderstanding of how the discussions have occurred17 and that the Python Packaging User Survey somehow happened in a vacuum (it was extensively discussed with lots of input from PyPA members).\nThat blog post has captured the current discourse around Python packaging and set the tone: one painting the volunteers who currently maintain the tooling as being “vs reality”.\nThis is exactly the sort of thing that happens when there’s no authoritative voice in the space: the vacuum will be filled by someone else on the internet, who will likely be making sensational claims that aren’t being validated before being repeated.\nOn formal UX analysis This has been mentioned in multiple places and has come up in the past in other contexts around Python Packaging.\nI think doing “full UX analysis” is going to be forbiddingly difficult. Don’t get me wrong: a complete UX review of the Python Packaging ecosystem would be awesome as part of a coordinated effort to make progress on the fundamental problems here.\nSomething like this is unlikely to happen because there’s a really motivated UX expert with a lot of volunteer time to donate. We’d basically need an enormous cheque for work that’s… “understand Python packaging really well and figure out a path to making it better”. That’s a difficult thing to tell a funder to throw money at.\nNotably, there’s a lot of stakeholders here: the easiest “persona” to identify is the maintainers of the tools themselves. After that, it starts to become fuzzy quickly. There’s redistributors, end users, Linux OS distros, Linux-specific non-OS package managers, cross-platform distributions, direct users, corporate users who have their own internal packaging systems, or like astronomers, students, statisticians, business analysts, and more.\nBreaking the UX problem into a smaller piece, like a single point from the dimensions we could unify, makes this a much more meaningfully sized piece for seeking funding toward. Even then, it’ll still probably only be available to be funded by the larger wallets and likely need to be a part of a project that has some other deliverables.\nAcknowledgements I’d like to thank the following people for reviewing drafts of this post at various stages and providing valuable feedback: Donald Stufft, Kushal Das, and Pavithra Eswaramoorthy.\nAlso, I would’ve appreciated if the discourse on this wasn’t moving along at the speed that it’s been moving after I publicly committed to writing this. And, yes, I’m aware that some of the things I’ve said here are conclusions that been reached by the broader group on that thread.\nFinally, I do have more thoughts; especially on how to get to a better place, but ~6k words is about as long as I want to go here.\nI’m very happy that we have done this.\nI’d initially discussed the idea of surveying users specifically on Python Packaging things to Shamika, the Python Packaging Project Manager, in late 2021, in an video call with her.\nI’m very grateful for the work that Shamika and many others have put toward this; the 2021 Python Developer Survey included a full section on Python Packaging (some are questions that I’d suggested!) and there’s been a dedicated 2022 Python Packaging Survey which has some extremely valuable data. ↩︎\nThat’s what the cool kids say now – it’s a bit of a mouthful, but it’s more accurate than PEP 517, and better than PEP 517/518/621/660-based build systems. ;) ↩︎\nI’m referring to distutils2 / setuptools / distribute. ↩︎\nThe 2013/2014/2015 StackOverflow survey results are a fun trip down technology history. PHP is more popular than Python. “Node.js and AngularJS are busting out”. “Java is still the #1 server side language”. ↩︎\nThe PyPA goals should really be updated, once the dust has settled around the whole strategy discussion. ↩︎\nBefore an individual with a controlling attitude got involved and made some overzealous marketing claims, and… then this was published. ↩︎\nSetuptools is not gonna installed by default in a venv, starting with Python 3.12 and only shipped with Python because it was needed by pip, prior to pyproject.toml-based builds being a thing. ↩︎\nYes, I know about Linux distros that break things. Yes, I know that you have a --without-pip (or equivalent) flag on venv/virtualenv. They’re both edge cases in this context, not the norm. ↩︎\n“90% of developers report they use pip to install Python packages” and even those who just use Conda/Poetry/PDM etc will end up using pip under the hood. ↩︎\nPoetry’s dependency resolver and lockfile operates under the assumption that all files for a package + version are going to have the exact same metadata. While it is a choice that Poetry can make, because it’s “opinionated”, it’s not something that other tools can do.\nNotably, it’s an incorrect assumption; baked in because PyPI’s rough-draft-became-production implementation of metadata handling treated metadata from the first wheel uploaded to PyPI as the releases’ metadata. ↩︎\nI may be biased but it’s worth noting that Flit is part of why PEP 517 happened. ↩︎\nClarified on the PyPA Discord as:\n“basically adding a dependency on the PEP 517 library and having a conditional that if the build backend is not Hatchling then use that”\nThat doesn’t seem like an “extraordinary” amount of work to me, but I’m not familiar with the Hatch codebase and I am willing to trust @ofek’s judgement here. ↩︎\nI’m absolutely looking at LWN’s summary here. More on this later. ↩︎\nunintentionally. I don’t think anyone came out thinking “We should design for a bad UX” but here we are. ↩︎\nIf you clicked the link and think like me: yes, I checked, I did reasonably well in my Data Structures and Algorithms course. ↩︎\nIn case someone from LWN ends up reading this: I think directing readers toward the post and repeating claims from it were bad editorial choices. Tacking on “(opinionated)” once is grossly insufficient, given the inaccuracy of claims in the post as well as the one you’ve repeated. ↩︎\nThose links are in “Summary of discussions” – discussions that most participants have already participated in. Plus, I’m pretty sure Discourse doesn’t count middle-clicks. ↩︎\n","wordCount":"5458","inLanguage":"en","datePublished":"2023-01-21T00:00:00Z","dateModified":"2023-01-21T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://pradyunsg.me/blog/2023/01/21/thoughts-on-python-packaging/"},"publisher":{"@type":"Organization","name":"Pradyun Gedam","logo":{"@type":"ImageObject","url":"https://pradyunsg.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pradyunsg.me/ accesskey=h title="Pradyun Gedam (Alt + H)">Pradyun Gedam</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://pradyunsg.me/about/ title=about><span>about</span></a></li><li><a href=https://pradyunsg.me/blog/ title=Blog><span>blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Thoughts on the Python packaging ecosystem</h1><div class=post-meta>Last updated January 21, 2023&nbsp;·&nbsp;26 minutes</div></header><div class=post-content><p>My response to the discussion topic posed in <a href="https://discuss.python.org/t/python-packaging-strategy-discussion-part-1/22420?u=pradyunsg">Python Packaging Strategy Discussion Part 1</a> had become quite long, so I decided to move it to write a blog post instead. This post then started absorbing various draft posts I&rsquo;ve had on this topic since this blog was started, morphing to include my broader thoughts on where we are today.</p><p><em>Note</em>: I&rsquo;ve updated this to cover an aspect of the recent LWN article on the topic as well.</p><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p>This post is a bit long, so here&rsquo;s the key points I&rsquo;m making:</p><ul><li>The Python packaging ecosystem <em>unintentionally</em> became the type of competitive space that it is today.</li><li>The community needs to make an explicit decision if it should continue operating under the model that led to status quo.</li><li>Pick from N different tools that do N different things is a good model.</li><li>Pick from N ~equivalent choices is a <em>really bad</em> user experience.</li><li>Picking a default doesn&rsquo;t make other approaches illegal.</li><li>Communication about the Python packaging ecosystem is fragmented, and we should improve that.</li></ul><hr><details><summary>My experience around Python Packaging</summary><p>At the time of writing:</p><ul><li>I&rsquo;m a maintainer on pip, installer, resolvelib, packaging, flit, Spack (allegedly), sphinx-theme-builder, pyproject-hooks, and more.</li><li>I&rsquo;m a moderator on PyPI.</li><li>I&rsquo;ve contributed in varying manners to setuptools, wheel, warehouse (i.e. PyPI), pipenv, Poetry, packaging.python.org, build, and more.</li><li>As a maintainer on pip, I&rsquo;m a member of the Python Packaging Authority (PyPA).</li><li>I&rsquo;ve co-authored multiple <a href=https://peps.python.org/topic/packaging/>Packaging PEPs</a>, including the <a href=https://www.python.org/dev/peps/pep-0609/>PyPA&rsquo;s Governance Model</a>.</li><li>I&rsquo;ve been the PEP-Delegate on multiple Packaging PEPs, trusted to make decisions on behalf of the community.</li></ul></details><h2 id=python-users-are-_not_-software-engineers>Python users are <em>not</em> software engineers<a hidden class=anchor aria-hidden=true href=#python-users-are-_not_-software-engineers>#</a></h2><p>Many of the users who write Python code are <em>not</em> primarily full-time software engineers or &ldquo;developers&rdquo;. They are not particularly interested in this aspect of their job. They&rsquo;re using Python as a tool to get their job done. They&rsquo;re not interested in the details of how the tool works, or even how complicated things are under the hood.</p><p>As Thea (Stargirl) Flowers <a href=https://hachyderm.io/@stargirl/109697057391904145>said recently</a>:</p><blockquote><p>The reason there are so many tools for managing Python dependencies is because Python is not a monoculture and different folks need different things.</p></blockquote><h2 id=user-expectations-for-a-default-workflow>User expectations for a &ldquo;default&rdquo; workflow<a hidden class=anchor aria-hidden=true href=#user-expectations-for-a-default-workflow>#</a></h2><p>A class of users expect a packaging tool that provides a cohesive experience (like npm (NodeJS), cargo (Rust), gem (Ruby), pub (Dart), dotnet (C#/.NET), etc) &ndash; a single tool that provides a build system, dependency manager, publishing, running project-specific tasks/scripts, etc. I&rsquo;ve referred to this as &ldquo;workflow tool&rdquo; in this post.</p><p>Certain other ecosystems have this in their &ldquo;default&rdquo; tool, providing a much more streamlined experience for users. I have first hand experience of this for NodeJS and Rust, where they have a single tool that users invoke to do the majority of their work:</p><ul><li>create a new project.</li><li>install/manage dependencies.</li><li>run their project w/ those dependencies.</li><li>test their project.</li><li>publish their project.</li><li>more?!</li></ul><p>Today, each of these pieces is a separate tool for Python and doesn&rsquo;t have a strict 1:1 mapping to the &ldquo;best practices&rdquo;/&ldquo;secure&rdquo; workflows. This is at odds with the expectations that these users have. This class of users, by and large, want consolidation and a single-tool experience.</p><p>We know that this class of users exists because we have:</p><ul><li>a number of popular tools that are attempting to provide this experience.</li><li>results from user surveys we&rsquo;ve done<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> <a href=https://drive.google.com/file/d/1U5d5SiXLVkzDpS0i1dJIA4Hu5Qg704T9/view>clearly indicate this</a> as well.</li><li>had multiple community members say this in multiple ways, across multiple channels.</li></ul><h2 id=flexibility-leads-to-complexity>Flexibility leads to complexity<a hidden class=anchor aria-hidden=true href=#flexibility-leads-to-complexity>#</a></h2><p>Brian Skinn <a href="https://discuss.python.org/t/packaging-vision-and-strategy-next-steps/21513/8?u=pradyunsg">said recently</a>:</p><blockquote><p>You can package darn near anything in Python, even though it may take figuring out a complicated three-step-and-a-hop process to get there… and I suspect that this has been part of what’s enabled Python to grow into its “second best programming language for every task” aphorism.</p></blockquote><p>I think there&rsquo;s some truth to that. <a href=https://packaging.python.org/en/latest/overview/>&ldquo;An Overview of Packaging for Python&rdquo;</a> on packaging.python.org expresses a similar tone as well:</p><blockquote><p>Packaging in Python has a bit of a reputation for being a bumpy ride. This impression is mostly a byproduct of Python’s versatility.</p></blockquote><p>I do want to contrast this with the fact that the overview page takes over 3000 words, to provide the &ldquo;high-level&rdquo; overview for how one can approach packaging a Python project. It doesn&rsquo;t even touch the specifics of configuration or provide any specific workflow guidance with that much digital ink.</p><p>The bumpy ride reputation is not misplaced, and is the most frequent user complaint (more on this later). There are consequences to the degree of flexibility afforded to users by the Python packaging ecosystem:</p><ul><li>every Python project has to make multiple decisions about how they want to do certain things</li><li>every Python user has to make choices for how they wanna manage their Python installation and workflow tools</li><li>it leads to multiple ways to achieve the same thing when trying to use Python packaging tools, with some of these ways being subtly wrong</li><li>it leads to a larger surface area of behaviours of existing/established tools that users rely upon.</li><li>it makes it much more likely that new users hit edge cases and paper-cuts, that more-experienced developers won&rsquo;t hit because they have adapted their workflow to avoid certain failure modes over time.</li></ul><p>The flexibility is <em>great</em> to have when you need it but, without a &ldquo;default&rdquo; workflow, it serves to create more user confusion than it resolves. It contributes to the bumpy ride reputation and to the perceived complexity.</p><h2 id=placing-the-python-packaging-ecosystem-on-the-community-spectrum>Placing the Python packaging ecosystem on the community spectrum<a hidden class=anchor aria-hidden=true href=#placing-the-python-packaging-ecosystem-on-the-community-spectrum>#</a></h2><p>When I was reading <a href=https://www.harihareswara.net/posts/2022/the-community-spectrum-caring-to-combative-insight-from-alex-bayley/>&ldquo;The community spectrum: caring to combative&rdquo; - Insight From Alex Bayley</a> on <a href=https://www.harihareswara.net/>Sumana Harihareswara&rsquo;s blog</a>, it flagged something amusing to me. I recommend reading the article, but I&rsquo;ll quote a portion that provides sufficient context for the rest of this post.</p><blockquote><p>The Competitive Spectrum describes communities as being:</p><ul><li><strong>Caring</strong>: members are motivated by helping each other.</li><li><strong>Collaborative</strong>: members share goals and help each other to achieve them.</li><li><strong>Cordial</strong>: members have their own goals which do not conflict with each other.</li><li><strong>Competitive</strong>: members share the same goals, and compete against each other to achieve them.</li><li><strong>Combative</strong>: members must achieve their goals by preventing others from being doing so.</li></ul></blockquote><h3 id=pypa-and-conda>PyPA and Conda<a hidden class=anchor aria-hidden=true href=#pypa-and-conda>#</a></h3><p>Within this spectrum, I think the relationship between Conda and PyPA projects is definitely collaborative.</p><p>The two groups of maintainers have worked together to solve problems that affect both groups. Conda packages are often built up from Python packages that are built with PyPA tools. Heck, at the time of writing, <a href=https://github.com/jezdez/>one of</a> the <a href=https://gist.github.com/jezdez/6222d1ba8b10d734d003492e58041687>founders of the PyPA</a> currently <a href="https://github.com/conda-incubator/governance/blob/0fa0e84f690e628fe7a232bb52938409b2fbc1e3/steering.csv?plain=1#L14">sits on the Conda Steering Council</a>.</p><h3 id=python-build-backends>Python build-backends<a hidden class=anchor aria-hidden=true href=#python-build-backends>#</a></h3><p>The goal of enabling pyproject.toml-based builds<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> was to move Python packaging from a collaborative (or at least, cordial) model, to a competitive model for the build mechanisms.</p><p>The stated goal of PEP 517 is:</p><blockquote><p>The goal of this PEP is get distutils-sig out of the business of being a gatekeeper for Python build systems. If you want to use distutils, great; if you want to use something else, then that should be easy to do using standardized methods.</p></blockquote><p>Moving to a competitive model for build mechanisms was intended to enable the ecosystem to move away from the &ldquo;only one way&rdquo; of building Python packages (the quote is from the Zen of Python) <em>because</em> the <a href=https://peps.python.org/pep-0517/#abstract>implementation we had of &ldquo;only one way&rdquo; was exceedingly difficult to evolve</a>.</p><h3 id=poetry--pdm--hatch--pyflow--etc>Poetry / PDM / Hatch / PyFlow / etc<a hidden class=anchor aria-hidden=true href=#poetry--pdm--hatch--pyflow--etc>#</a></h3><p>These tools are firmly in a competitive model. They&rsquo;re competing for users. They&rsquo;re competing to be the &ldquo;best&rdquo; solution to the &ldquo;workflow&rdquo; problem. They&rsquo;re, arguably, even competing for contributors.</p><p>Other than the obvious sign that these tools can&rsquo;t be used together on the same codebase (mostly), this can be seen in other aspects of these projects:</p><ul><li>the way they&rsquo;re marketed/documented &ndash; they have an incentive to invest in this, because they&rsquo;re competing for users and good-looking/flashy documentation is a good way to attract users.</li><li>the way they do community management: some have dedicated community Discord servers, mention $tool-specific ecosystems, have their own $tool plugin ecosystems, etc.</li><li>the way their users advocate for them as the one-true-solution on the internet :)</li></ul><p>This competition also leads to incentives for projects to do things like implementing <a href=https://github.com/pypa/hatch/commit/fea611be96f79559ecf227d2a68b6dfbf3b3c2ec>draft standards that are not accepted or settled</a> and <a href=https://pradyunsg.me/blog/2023/01/21/pdm-does-not-implement-pep-582/>claims that standards are implemented, even when the implementation does not match the standard</a>.</p><h2 id=unintended-competition>Unintended competition<a hidden class=anchor aria-hidden=true href=#unintended-competition>#</a></h2><p>In my opinion, ending up with multiple competing workflow tools in the Python ecosystem was not an intentional choice by any individual or group.</p><p>While providing alternatives to distutils/setuptools was the intent of pyproject.toml-based build systems, I don&rsquo;t think it was intended nor was there ever consensus that we wanted to end up with an ecosystem of competing tools which <em>use</em> the pyproject.toml-based build system <em>and</em> provide an end-to-end workflow.</p><p>I don&rsquo;t see any discussion of such tooling in the corresponding mailing list discussions and the PEPs certainly don&rsquo;t talk about trying to enable building alternative <em>workflow</em>-related tooling. There&rsquo;s extensive discussion about the technical design of the final solution and on many aspects of &ldquo;how to build distribution files&rdquo;, but there&rsquo;s no discussion about how competing workflow tools would be enabled.</p><p>Another reason is&mldr; well&mldr; let&rsquo;s dig into some &ldquo;history&rdquo;. The Python Packaging Authority has <a href=https://www.pypa.io/en/latest/future/>publicly written goals</a> for them:</p><blockquote><ul><li>Although it’s still being defined, to work towards a “Meta-Packaging” system that:<ul><li>Clearly delineates the phases of distribution</li><li>Allows for multiple interacting tools vs one monolithic tool</li><li>Specifically allows for alternative build systems, i.e. a “MetaBuild” system.</li></ul></li></ul></blockquote><p>These goals were <a href=https://github.com/pypa/pypa.io/blob/2ddc43fa4871e83365b8f43da19b7dc573b67ebd/source/future.rst>written in a different &ldquo;era&rdquo; of Python packaging</a>, before PEP 516/517/518 were being debated, when the ecosystem was still in an entirely collaborative/cordial model (on the other side of a combative era<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>), and when the &ldquo;Python ecosystem&rdquo; was much smaller than it is today<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p><p>The intent was to enable the ecosystem to build multiple tools that interacted with each other and allow for alternative build tooling to solve problems that were difficult to solve with distutils/setuptools.</p><p>A competitive ecosystem for workflow tooling is an unintended consequence of the pyproject.toml-based build system. The PyPA&rsquo;s focus on standardisation made it easier to build workflow tooling that interacted with other packages, with no mechanisms to check whether these tools are reciprocating on interoperability.</p><h2 id=on-existing-workflow-tools>On existing workflow tools<a hidden class=anchor aria-hidden=true href=#on-existing-workflow-tools>#</a></h2><p>I expect the most relevant people already know this, but I&rsquo;ll state it explicitly: I have a lot of respect for the work done by the authors and/or maintainers of tooling like Poetry, PDM, Hatch, Pipenv, PyFlow, etc. I think they each, individually, contribute meaningfully and positively to the ecosystem.</p><p>The most popular workflow tools for Python handle the underlying details for the user and give them a single unified tool that has <code>install</code> / <code>publish</code> / <code>run</code> commands. They also provide functionality that the &ldquo;default&rdquo; tools do not (eg: environment-agnostic lockfiles, automated environment management etc). Serving as an end-to-end tool enables them to trim the scope and define it as they deem appropriate.</p><p>Conda also does this to a certain extent, by tying the <a href=https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html>environment management and package management together</a> into a single tool, but it also operates on a different level than these tools &ndash; packaging &ldquo;everything&rdquo; rather than just Python packages.</p><h3 id=the-reasons-for-the-existence-of-workflow-tools>The reasons for the existence of workflow tools<a hidden class=anchor aria-hidden=true href=#the-reasons-for-the-existence-of-workflow-tools>#</a></h3><p>Some/all of the &ldquo;workflow tools&rdquo; that exist today because the &ldquo;default&rdquo; tooling did not cover more of the user&rsquo;s workflow with a single piece.</p><ul><li>Pipenv&rsquo;s <code>Pipfile</code> was <a href=https://github.com/pypa/pip/issues/1795#issuecomment-261661124>created with the express goal of being for pip</a><sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>.</li><li>Poetry was <a href=https://github.com/python-poetry/poetry/blob/a5d6333f27f261458ba5abe3e30cbf452fa7a10f/README.md#why>created to provide a single config file with a single tool experience, and a better dependency resolution model</a>.</li><li>Hatch was <a href=https://github.com/pypa/hatch/blob/4202965f4a4b1d86e6c7de1224a359217df45314/README.rst>created as &ldquo;a productivity tool designed to make your workflow easier and more efficient, while also reducing the number of other tools you need to know.&rdquo;</a>.</li><li>PDM was <a href=https://github.com/pdm-project/pdm/commit/06391eca0bed7b879af1bc84c1c737c99646741e>created as a &ldquo;Python package manager with PEP 582 support&rdquo;</a> (which is notable, given that <a href=https://pradyunsg.me/blog/2023/01/21/pdm-does-not-implement-pep-582/>PDM does not implement PEP 582</a>).</li></ul><p>These tools have <em>all</em> now dropped that language from their documentation (or at least evolved it) to reflect that they&rsquo;re now focused on providing a complete and unified experience for the user. This can be seen by the fact that they&rsquo;ve all gone ahead and invented their own build-backends (except Pipenv, which is maintaining a fork of pip within it), since providing a complete and unified experience requires that the tool also controls how projects are built.</p><p>Now, to state the obvious, the folks who created these tools are not fools who like to create work for themselves or enjoy reinventing the wheel. They created because they felt that the existing tooling wasn&rsquo;t meeting their needs <em>and</em> that there was no clear path to improving the pre-existing tooling to meet those needs. Each of these tools solves the problem by making different calls for what the right trade-offs are.</p><p>I am certain that it is not possible to create a single &ldquo;workflow&rdquo; tool for Python software. What we have today, an ecosystem of tooling where each makes different design choices and technical trade-offs, is a part of why Python is as widespread as it is today. This flexibility and availability of choice is, however, both a blessing and a curse. That&rsquo;s actually a great segue to talk about&mldr;</p><h2 id=pip-a-privileged-player>pip: A privileged player<a hidden class=anchor aria-hidden=true href=#pip-a-privileged-player>#</a></h2><p>Today, <code>pip</code> is uniquely positioned within in the Python packaging ecosystem. It is the only<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> piece of the Python packaging tooling that ships with Python, and is guaranteed<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> to be installed in every environment. Nearly every Python user<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup> who wishes to share code (or use shared code) uses it today, directly or indirectly.</p><p>The fact that I&rsquo;ve added 3 footnotes in the last paragraph is a symptom of <em>something</em> and I&rsquo;m not sure if it&rsquo;s a good thing or a bad thing.</p><h2 id=pip-a-disadvantaged-player>pip: A disadvantaged player<a hidden class=anchor aria-hidden=true href=#pip-a-disadvantaged-player>#</a></h2><p>This point is easier to make with an example, let&rsquo;s take lockfiles: it&rsquo;s technically feasible to implement an arbitrary lockfile format in pip, that evolves with pip, in lock-step with it (something of this sort is implemented already in the form of pip-tools).</p><p>Given the privileged position that pip has within the ecosystem (i.e. ships with the language), whatever it does would become the de-facto standard and commercial tools/IDEs will add support for that model much quicker (eg: requirements.txt) than something similar from PDM, Poetry, Pipenv etc.</p><p>Now, on the face of it, this is a completely different direction from PyPA&rsquo;s model of &ldquo;interoperability standards through concensus&rdquo; because, effectively, whatever pip implements would become a de-facto standard for what the ecosystem and tooling supports.</p><p>On the other hand, if we focus on designing for interoperability through concensus before implementing functionality in pip, implementing vital workflow improvements is now blocked on an exhaustingly long process of a non-iterative, waterfall-style design process. Further, an interoperable lockfile format also has to try to satisfy needs to tools that use completely different resolution models <em>even</em> semantically incorrect ones<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>.</p><p>Taking a slightly iterative approach of &ldquo;we&rsquo;ll cover the more complicated case later&rdquo; caused <a href=https://peps.python.org/pep-0665/>the last proposal for a lockfile format standard</a> to be rejected after months of discussion.</p><p>We&rsquo;re in a state where the process for adding new functionality to our default &ldquo;out of the box&rdquo; experience is designed to be both very difficult and very &ldquo;energy&rdquo; intensive &ndash; leading to it being pretty slow. The reason the default tooling doesn&rsquo;t improve is that making meaningful improvements to it is blocked on trying to cater to all workflows; in ways that alternative tooling is not.</p><p>The effect of this is that our &ldquo;out of the box&rdquo; experience is always going to be worse than the experience with other tools in the ecosystem. In a competitive ecosystem, is that what we want? Heck, at that point, do we even want to be in a competitive ecosystem?</p><h2 id=on-build-backends-tied-to-workflow-tools>On build-backends tied to workflow tools<a hidden class=anchor aria-hidden=true href=#on-build-backends-tied-to-workflow-tools>#</a></h2><p>Hatchling, pdm-backend and poetry-core are all examples of this. Flit/flit-core is another slightly-weaker example of this<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup>. They each have build-backends that are either (a) tied to a particular workflow tool in some way or (b) promoted along with a workflow tool.</p><p>The build backends are all solving the &ldquo;build a wheel from Python code&rdquo; problem, but with different user experiences tacked onto them. Building multiple tools that solve the same problem is duplicated effort.</p><p>Part of the problem here is that these tools (with the exception of PDM) are not built with interoperability in their design, and these tools have basically little to no incentive to take on the complexities of providing interoperability.</p><p>Flit can only be used with flit_core, and <code>flit build</code> doesn&rsquo;t build the same artifacts as <code>python -m build</code> would.</p><p>Hatch is tied to hatchling, and <a href=https://github.com/pypa/hatch/issues/507>&ldquo;it would be an extraordinary amount of effort&rdquo;</a> to support using a different build-backend for your project when using Hatch.<sup id=fnref:12><a href=#fn:12 class=footnote-ref role=doc-noteref>12</a></sup></p><p>Poetry has its own dependency specification format, and the corresponding build-backend enables it to build packages that use that format.</p><p>PDM is better on this front, in that it has greater backend-agnostic behaviours to it. However, pdm-backend is undergoing a rewrite to <a href="https://discuss.python.org/t/python-packaging-strategy-discussion-part-1/22420/141?u=pradyunsg">&ldquo;provide a similar extensible interface to hatchling&rdquo;</a>.</p><p>These were all made possible by the explicit focus of the PyPA on designing an interoperability model &ndash; i.e. Unix-like approach &ndash; which these tools have used to create tool-specific build-backends. :)</p><p>While we trying to enforce that one way of building packages/managing dependencies for all Python users is not feasible&mldr; having 4 build-backends that all handle pure-Python packages with the same file holding their configuration, while providing slightly different user experiences is <em>also</em> not a good place to be in IMO.</p><h2 id=pick-from-n-equivalent-choices-is-really-bad-ux>Pick from N ~equivalent choices is really bad UX<a hidden class=anchor aria-hidden=true href=#pick-from-n-equivalent-choices-is-really-bad-ux>#</a></h2><p>When you package Python software, a user has to make a lot of choices. There are a <em>lot</em>, and I do mean a <em>lot</em>, of &ldquo;A vs B&rdquo; comparisons that you can make when it comes to figuring out the scaffolding for packaging and distributing Python software.</p><p>The problem with not making a default recommendation for these largely-inconsequential choices is that it means that <em>every</em> user has to make these choices. Instead of making a choice once and then being able to build upon that as an ecosystem, we keep moving in circles on these topics because we&rsquo;ve got two groups now and picking either choice means that the other group is unhappy.</p><p>This also leads to the same problems being solved twice &ndash; there&rsquo;s duplicated effort and duplicated documentation. Each project will design their own approach and there&rsquo;s incentive for projects to try to &ldquo;out-compete&rdquo; each other by providing more features or by providing better documentation, rather than contributing to improving a common corpus.</p><p>This is how, for example, we end up with <a href=https://packaging.python.org>packaging.python.org</a> not having <a href=https://packaging.python.org/en/latest/specifications/declaring-project-metadata/>a standard structure for declaring metadata that is implemented by ~every build-backend</a> documented, even though there was <em>extensive</em> documentation for the same in multiple tools&rsquo; own documentation for months. Each of those tools&rsquo; authors have had incentives to document it for their users and it was easier to do so in their own documentation where they don&rsquo;t have to worry about the concerns of other tools or &ldquo;being generic enough&rdquo;.</p><h2 id=not-a-pypa-project>&ldquo;not a PyPA project&rdquo;<a hidden class=anchor aria-hidden=true href=#not-a-pypa-project>#</a></h2><p>The <em>only</em> reason various Python packaging projects (notably, Poetry and PDM) are not PyPA projects is because they&rsquo;ve never asked to become one.</p><p>As it stands, the PyPA views itself as a big umbrella. Basically any established Python packaging project that asks to be included, will be accepted. If Poetry and PDM ever asked to join, as it stands, there&rsquo;s no version of this timeline where the existing PyPA members say no.</p><p>From the discussions I&rsquo;ve had, the reasons have ranged from some sense of maintaining control (which doesn&rsquo;t really have <a href=https://github.com/pypa/pipenv/issues/607#issuecomment-330878876>good precedence</a>), to logistical issues like GitHub Actions queues, as well as a sense of being able to &ldquo;be successful without the tag&rdquo;.</p><p>Also, to say that these tools are &ldquo;are not participating in the PyPA&rdquo;<sup id=fnref:13><a href=#fn:13 class=footnote-ref role=doc-noteref>13</a></sup> is incorrect. PDM&rsquo;s whole <a href="https://github.com/pdm-project/pdm/blob/c0974672a17be965ddcb0e191d35df08ad0c4b6e/README.md?plain=1#L5">pitch <em>today</em></a> is that it is &ldquo;A modern Python package and dependency manager supporting the latest PEP standards&rdquo;. Poetry&rsquo;s authors somewhat regularly interact with the interoperability discussions and its original author has even co-authored a PEP.</p><h2 id=on-the-python-packaging-authority>On the Python Packaging Authority<a hidden class=anchor aria-hidden=true href=#on-the-python-packaging-authority>#</a></h2><p>I think there&rsquo;s a need to reconsider what the Python Packaging Authority should be trying to do and what it even is. We&rsquo;ve been cruising on the premise that we&rsquo;re maintaining foundational tools and designing for interoperability is the &ldquo;right&rdquo; model for the Python packaging ecosystem. I&rsquo;m not sure that&rsquo;s the case.</p><p>Between the user surveys, having a $work role where I&rsquo;m directly influencing user workflows beyond the installer, spending time helping out with scientific Python tooling and with <a href=https://www.pyopensci.org/>pyOpenSci</a>, and the discussions in the strategy thread&mldr; I&rsquo;m starting to think that our current approach is not working and is harmful<sup id=fnref:14><a href=#fn:14 class=footnote-ref role=doc-noteref>14</a></sup> unintentionally. Each projects&rsquo; maintainers effectively decide on different aspects of the the overall UX. Each project acts as its own project. There is no broader guiding &ldquo;roadmap&rdquo;. Making decisions about how the default tooling of the ecosystem works is &ldquo;not appropriate&rdquo; for our process to hashing out technical design proposals. There is no &ldquo;blessed&rdquo; tool and yet there are defaults, things that ship with the Python standard library and PyPA recommendations.</p><p>I&rsquo;m not sure what the right answer is, but I don&rsquo;t think we&rsquo;re in a good place right now. Here&rsquo;s where we are:</p><ul><li>even co-operating tools are viewed as being in competition with each other</li><li>interoperability standards that are written but are not enforced<ul><li>on the principle of &ldquo;consenting adults&rdquo; or &ldquo;be permissive in what you accept&rdquo;</li><li>for backwards compatibility reasons</li><li>because &ldquo;we should trust the XYZ authors to do the right thing&rdquo;</li><li>difficult to answer basic questions like &ldquo;what can a source distribution file be named&rdquo; because the standard says one thing while the tools do something else because &ldquo;the author prefers that&rdquo;</li><li>implemented and publicized as features in tools, despite not being something that is &ldquo;accepted&rdquo;</li><li>absolutely ignored by tool authors &ldquo;because it&rsquo;s not a priority&rdquo;</li></ul></li><li>duplicated effort because multiple tools are competing</li><li>users are confused about what to use, what is deprecated, what is the &ldquo;right&rdquo; way to do things etc and there is no authoritative answer</li><li>say that PEPs are not documentation but, also, go read this PEP for the details on how this feature works because that&rsquo;s the only place we wrote it.</li><li>no clear answer for step 0 questions like where should I put by .py files relative to my pyproject.toml file</li><li>a lack of willingness to draw a line in the sand and say &ldquo;this is the way things are done&rdquo; because &ldquo;what if someone finds a better way in the future&rdquo;</li><li>we don&rsquo;t pick one of two ~equivalent choices because &ldquo;they&rsquo;re both valid workflows&rdquo;</li><li>there is <strong>no</strong> agreed upon direction for the ecosystem</li></ul><h2 id=we-dont-need-_more_-generic-build-backends-today>We don&rsquo;t need <em>more</em> &ldquo;generic&rdquo; build-backends today<a hidden class=anchor aria-hidden=true href=#we-dont-need-_more_-generic-build-backends-today>#</a></h2><p>With <a href=https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html>setuptools gaining pyproject.toml configuration support</a> and <a href=https://packaging.python.org/en/latest/specifications/declaring-project-metadata/>a standard structure for declaring metadata that is implemented by ~every build-backend</a>, there isn&rsquo;t a significant difference between the various tools for pure-Python packages.</p><p>There are only so many ways to construct a <code>.zip</code> file containing a bunch of pure-Python files + metadata. The only real difference is in the user experience, and the user experience is largely determined by the tooling that invokes the build-backend.</p><p>Building more build-backends that are intended to be extended (beyond what we already have, between <code>hatchling</code>, <code>pdm-backend</code> and <code>setuptools</code>) feels unnecessary to me; and we might already have one too many options for this.</p><h2 id=on-pip-as-a-workflow-tool>On pip as a workflow tool<a hidden class=anchor aria-hidden=true href=#on-pip-as-a-workflow-tool>#</a></h2><p>Donald Stufft has <a href=https://github.com/pypa/pip/issues/6041#issuecomment-516470124>said</a> on pip&rsquo;s issue tracker:</p><blockquote><p>All that being said, I think trying to follow the &ldquo;unix philosophy&rdquo; is a mistake and is actually a pretty poor UX. Yea a lot of nerds grok it because we&rsquo;ve caused enough collective brain damage by being forced to use it over time and it works better for the typical unix tools because they generally just come preinstalled. I think it would just add additional complexity to an already confusing landscape of tools for our end users.</p></blockquote><p>And, Paul Moore has <a href="https://discuss.python.org/t/adding-a-non-metadata-installer-only-dev-dependencies-table-to-pyproject-toml/20106/10?u=pradyunsg">said</a>:</p><blockquote><p>At some point, I do think that pip needs to make a firm decision on whether it’s a development workflow tool or just an installer</p></blockquote><p>And, I think that now is the time to make that decision.</p><p>The <a href="https://discuss.python.org/t/python-packaging-strategy-discussion-part-1/22420?u=pradyunsg">recent strategy discussion</a> is sprawling and has largely operated with the assumption that pip is not something that can become a &ldquo;workflow tool&rdquo;. I think that&rsquo;s an incorrect assumption.</p><p>Personally, I&rsquo;ve wanted pip to cover more aspects of the user&rsquo;s workflow <a href=https://github.com/pypa/pip/issues/5407#issuecomment-389621303>since before PEP 517 was implemented</a>, which was around the time <a href=http://pradyunsg.me/gsoc-2017/05/05/green-light/>I started getting involved in Python</a><sup id=fnref:15><a href=#fn:15 class=footnote-ref role=doc-noteref>15</a></sup>. Improving the &ldquo;base&rdquo; tool to cover more use cases is <strong>not</strong> a bad idea &ndash; it&rsquo;s helpful for most user personas. Outside of blessing another tool, this is the path of least resistance that we can take to getting to a better state.</p><p>Do I think there&rsquo;s a significant amount of work needed for making pip into a workflow tool?</p><p>Yes.</p><p>Do I think that the amount of energy that&rsquo;s gone into Poetry/Hatch/Pipenv/PDM development, collectively, would have made more than a meaningful dent at this issue?</p><p>Yes.</p><p>Do I think that, at this point, blessing another tool is a good idea?</p><p>Maybe. We&rsquo;ve built a competitive ecosystem, and I don&rsquo;t think we can just &ldquo;pick one&rdquo; of the &ldquo;new things&rdquo; and expect that to be the end of it.</p><p>Did we ever have sufficient buy-in + capacity to do this with pip, along with contributor experiences that would facilitate this?</p><p>No. That&rsquo;s been a part of the problem &ndash; we&rsquo;ve made it fairly tractable to &ldquo;build your own&rdquo; in a sandbox that lets you ignore the need to support entire swaths of workflows, and that&rsquo;s something you can&rsquo;t compete with easily for contributor experience. And, when the alternative is &ldquo;spend a few months trying to implement something in a &rsquo;legacy&rsquo; codebase, while catering to needs that you don&rsquo;t have, also convince a bunch of people with limited availability that your idea is a good one and wait for them to review what you wrote&rdquo;, it&rsquo;s not surprising that we end up with a bunch of &ldquo;new things&rdquo; and have multiple groups building multiple workflow tools.</p><p>We <em>still</em> don&rsquo;t have agreement that this is the direction that we, as a community, want pip to go.</p><h2 id=on-user-facing-communication>On user-facing communication<a hidden class=anchor aria-hidden=true href=#on-user-facing-communication>#</a></h2><p>There&rsquo;s no single place where users can go to get information about the Python packaging ecosystem &ndash; either on how it&rsquo;s evolving or what the functional best-practices are <em>today</em>. We either (a) don&rsquo;t have them documented or (b) don&rsquo;t have a good approach to communicating about this to end users.</p><p>There&rsquo;s a cost to this.</p><p>LWN <a href=https://lwn.net/SubscriberLink/920132/cb4d6c0f07b54952/>recently</a> directed readers to a blog post<sup id=fnref:16><a href=#fn:16 class=footnote-ref role=doc-noteref>16</a></sup> that claims that the strategy discussion is evidence that &ldquo;PyPA must be destroyed&rdquo;, implies that there&rsquo;s &ldquo;ivory towers of packaging tool maintainers&rdquo;, that &ldquo;half of the discussion participants did not even bother reading what the people think&rdquo; based on a misunderstanding of how the discussions have occurred<sup id=fnref:17><a href=#fn:17 class=footnote-ref role=doc-noteref>17</a></sup> and that the Python Packaging User Survey somehow happened in a vacuum (it was <a href=https://discuss.python.org/t/rfc-survey-to-help-define-a-python-packaging-vision-and-strategy/15658>extensively</a> <a href=https://discuss.python.org/t/your-feedback-required-python-packaging-user-survey/18070>discussed</a> with lots of input from PyPA members).</p><p>That blog post has captured the current discourse around Python packaging and set the tone: one painting the volunteers who currently maintain the tooling as being &ldquo;vs reality&rdquo;.</p><p>This is exactly the sort of thing that happens when there&rsquo;s no authoritative voice in the space: the vacuum will be filled by someone else on the internet, who will likely be making sensational claims that aren&rsquo;t being validated before being repeated.</p><h2 id=on-formal-ux-analysis>On formal UX analysis<a hidden class=anchor aria-hidden=true href=#on-formal-ux-analysis>#</a></h2><p>This has been mentioned in multiple places and has come up in the past in other contexts around Python Packaging.</p><p>I think doing &ldquo;full UX analysis&rdquo; is going to be forbiddingly difficult. Don&rsquo;t get me wrong: a complete UX review of the Python Packaging ecosystem would be <em>awesome</em> as part of a coordinated effort to make progress on the fundamental problems here.</p><p>Something like this is unlikely to happen because there&rsquo;s a <em>really</em> motivated UX expert with a <em>lot</em> of volunteer time to donate. We&rsquo;d basically need an enormous cheque for work that&rsquo;s&mldr; &ldquo;understand Python packaging really well and figure out a path to making it better&rdquo;. That&rsquo;s a difficult thing to tell a funder to throw money at.</p><p>Notably, there&rsquo;s a lot of stakeholders here: the easiest &ldquo;persona&rdquo; to identify is the maintainers of the tools themselves. After that, it starts to become fuzzy quickly. There&rsquo;s redistributors, end users, Linux OS distros, Linux-specific non-OS package managers, cross-platform distributions, direct users, corporate users who have their own internal packaging systems, or like astronomers, students, statisticians, business analysts, and more.</p><p>Breaking the UX problem into a smaller piece, like a single point from the <a href="https://discuss.python.org/t/python-packaging-strategy-discussion-part-1/22420/16?u=pradyunsg">dimensions we could unify</a>, makes this a much more meaningfully sized piece for seeking funding toward. Even then, it&rsquo;ll still probably only be available to be funded by the larger wallets and likely need to be a part of a project that has some other deliverables.</p><h2 id=acknowledgements>Acknowledgements<a hidden class=anchor aria-hidden=true href=#acknowledgements>#</a></h2><p>I&rsquo;d like to thank the following people for reviewing drafts of this post at various stages and providing valuable feedback: Donald Stufft, Kushal Das, and Pavithra Eswaramoorthy.</p><p>Also, I would&rsquo;ve appreciated if the discourse on this wasn&rsquo;t moving along at the speed that it&rsquo;s been moving after <a href="https://discuss.python.org/t/python-packaging-strategy-discussion-part-1/22420/16?u=pradyunsg">I publicly committed to writing this</a>. And, yes, I&rsquo;m aware that some of the things I&rsquo;ve said here are conclusions that been reached by the broader group on that thread.</p><p>Finally, I do have more thoughts; especially on how to get to a better place, but ~6k words is about as long as I want to go here.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>I&rsquo;m <em>very</em> happy that we have done this.</p><p>I&rsquo;d initially discussed the idea of surveying users specifically on Python Packaging things to Shamika, <a href=https://pyfound.blogspot.com/2021/04/the-psf-is-hiring-python-packaging.html>the Python Packaging Project Manager</a>, in late 2021, in an video call with her.</p><p>I&rsquo;m very grateful for the work that Shamika and many others have put toward this; the 2021 Python Developer Survey included a <a href=https://lp.jetbrains.com/python-developers-survey-2021/#PythonPackaging>full section on Python Packaging</a> (some are questions that I&rsquo;d suggested!) and there&rsquo;s been a dedicated <a href=https://drive.google.com/file/d/1U5d5SiXLVkzDpS0i1dJIA4Hu5Qg704T9/view>2022 Python Packaging Survey</a> which has some extremely valuable data.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>That&rsquo;s what the cool kids say now &ndash; it&rsquo;s a bit of a mouthful, but it&rsquo;s more accurate than PEP 517, and better than PEP 517/518/621/660-based build systems. ;)&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>I&rsquo;m referring to distutils2 / setuptools / distribute.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://insights.stackoverflow.com/survey/2015#tech-lang>The 2013/2014/2015 StackOverflow survey results</a> are a fun trip down technology history. PHP is more popular than Python. &ldquo;Node.js and AngularJS are busting out&rdquo;. &ldquo;Java is still the #1 server side language&rdquo;.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>The PyPA goals should really be updated, once the dust has settled around the whole strategy discussion.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>Before an individual with a <a href=https://github.com/pypa/pipenv/issues/607#issuecomment-330878876>controlling attitude</a> got involved and made some <a href=https://github.com/pypa/pipfile/pull/138>overzealous marketing claims</a>, and&mldr; <a href=https://vorpus.org/blog/why-im-not-collaborating-with-kenneth-reitz/>then this was published</a>.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p><a href=https://github.com/python/cpython/pull/101039>Setuptools is not gonna installed by default in a <code>venv</code>, starting with Python 3.12</a> and only shipped with Python because it was needed by pip, prior to pyproject.toml-based builds being a thing.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>Yes, I know about Linux distros that break things. Yes, I know that you have a <code>--without-pip</code> (or equivalent) flag on venv/virtualenv. They&rsquo;re both edge cases in this context, <em>not</em> the norm.&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p><a href=https://lp.jetbrains.com/python-developers-survey-2021/#text-530>&ldquo;90% of developers report they use pip to install Python packages&rdquo;</a> and even those who just use Conda/Poetry/PDM etc will end up using pip under the hood.&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p>Poetry&rsquo;s dependency resolver and lockfile operates under the assumption that <em>all</em> files for a package + version are going to have the exact same metadata. While it is a choice that Poetry can make, because it&rsquo;s &ldquo;opinionated&rdquo;, it&rsquo;s not something that other tools can do.</p><p>Notably, it&rsquo;s an incorrect assumption; baked in because PyPI&rsquo;s rough-draft-became-production implementation of metadata handling treated metadata from the first wheel uploaded to PyPI as the releases&rsquo; metadata.&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p>I <a href=https://pradyunsg.me/about/#flit>may be biased</a> but it&rsquo;s worth noting that Flit is part of <em>why</em> PEP 517 happened.&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:12><p>Clarified on the <a href=https://discord.com/channels/803025117553754132/964878415914213436/1063852982459957248>PyPA Discord</a> as:</p><blockquote><p>&ldquo;basically adding a dependency on the PEP 517 library and having a conditional that if the build backend is not Hatchling then use that&rdquo;</p></blockquote><p>That doesn&rsquo;t seem like an &ldquo;extraordinary&rdquo; amount of work to me, but I&rsquo;m not familiar with the Hatch codebase and I am willing to trust @ofek&rsquo;s judgement here.&#160;<a href=#fnref:12 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:13><p>I&rsquo;m absolutely looking at LWN&rsquo;s summary here. More on this later.&#160;<a href=#fnref:13 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:14><p>unintentionally. I don&rsquo;t think anyone came out thinking &ldquo;We should design for a bad UX&rdquo; but here we are.&#160;<a href=#fnref:14 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:15><p>If you clicked the link and think like me: yes, I checked, I did reasonably well in my Data Structures and Algorithms course.&#160;<a href=#fnref:15 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:16><p>In case someone from LWN ends up reading this: I think directing readers toward the post and repeating claims from it were bad editorial choices. Tacking on &ldquo;(opinionated)&rdquo; once is grossly insufficient, given the inaccuracy of claims in the post as well as the one you&rsquo;ve repeated.&#160;<a href=#fnref:16 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:17><p>Those links are in &ldquo;Summary of discussions&rdquo; &ndash; discussions that most participants have already participated in. Plus, I&rsquo;m pretty sure Discourse doesn&rsquo;t count middle-clicks.&#160;<a href=#fnref:17 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://pradyunsg.me/tags/python-packaging/>Python packaging</a></li></ul><nav class=paginav><a class=prev href=https://pradyunsg.me/blog/2023/01/21/pdm-does-not-implement-pep-582/><span class=title>« Newer</span><br><span>PDM does not implement PEP 582</span></a>
<a class=next href=https://pradyunsg.me/blog/2023/01/14/python-packaging-organisation/><span class=title>Older »</span><br><span>How the Python Packaging community is organised</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://pradyunsg.me/>Pradyun Gedam</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
with tweaks.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>