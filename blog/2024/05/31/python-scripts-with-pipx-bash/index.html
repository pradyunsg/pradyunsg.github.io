<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Improving my dotfiles manager with pipx and inline dependency metadata | Pradyun Gedam</title>
<meta name=keywords content="Python,dotfiles"><meta name=description content="I have a (somewhat unnecessarily) custom setup for managing my dotfiles and I made a nice improvement to it today.
How it works The dotfiles are managed by a Python script. In broad strokes, the script will:
read a TOML file locate the configured paths create symlinks, based on custom marker text in the filenames, for files in subdirectories under the configured paths1 If there&rsquo;s a conflict (i.e. two configured paths provide the same symlink target location), the TOML file contains the resolution for it (i."><meta name=author content><link rel=canonical href=https://pradyunsg.me/blog/2024/05/31/python-scripts-with-pipx-bash/><link crossorigin=anonymous href=/assets/css/stylesheet.187c2d5911ee36d5bc65695fd777b1318dd7927b49b8ce1f7384b8a0cad6a95e.css integrity="sha256-GHwtWRHuNtW8ZWlf13exMY3XkntJuM4fc4S4oMrWqV4=" rel="preload stylesheet" as=style><link rel=icon href=https://pradyunsg.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pradyunsg.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pradyunsg.me/favicon-32x32.png><link rel=apple-touch-icon href=https://pradyunsg.me/apple-touch-icon.png><link rel=mask-icon href=https://pradyunsg.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Improving my dotfiles manager with pipx and inline dependency metadata"><meta property="og:description" content="I have a (somewhat unnecessarily) custom setup for managing my dotfiles and I made a nice improvement to it today.
How it works The dotfiles are managed by a Python script. In broad strokes, the script will:
read a TOML file locate the configured paths create symlinks, based on custom marker text in the filenames, for files in subdirectories under the configured paths1 If there&rsquo;s a conflict (i.e. two configured paths provide the same symlink target location), the TOML file contains the resolution for it (i."><meta property="og:type" content="article"><meta property="og:url" content="https://pradyunsg.me/blog/2024/05/31/python-scripts-with-pipx-bash/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-05-31T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Improving my dotfiles manager with pipx and inline dependency metadata"><meta name=twitter:description content="I have a (somewhat unnecessarily) custom setup for managing my dotfiles and I made a nice improvement to it today.
How it works The dotfiles are managed by a Python script. In broad strokes, the script will:
read a TOML file locate the configured paths create symlinks, based on custom marker text in the filenames, for files in subdirectories under the configured paths1 If there&rsquo;s a conflict (i.e. two configured paths provide the same symlink target location), the TOML file contains the resolution for it (i."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Scribbled Notes","item":"https://pradyunsg.me/blog/"},{"@type":"ListItem","position":2,"name":"Improving my dotfiles manager with pipx and inline dependency metadata","item":"https://pradyunsg.me/blog/2024/05/31/python-scripts-with-pipx-bash/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Improving my dotfiles manager with pipx and inline dependency metadata","name":"Improving my dotfiles manager with pipx and inline dependency metadata","description":"I have a (somewhat unnecessarily) custom setup for managing my dotfiles and I made a nice improvement to it today.\nHow it works The dotfiles are managed by a Python script. In broad strokes, the script will:\nread a TOML file locate the configured paths create symlinks, based on custom marker text in the filenames, for files in subdirectories under the configured paths1 If there\u0026rsquo;s a conflict (i.e. two configured paths provide the same symlink target location), the TOML file contains the resolution for it (i.","keywords":["Python","dotfiles"],"articleBody":"I have a (somewhat unnecessarily) custom setup for managing my dotfiles and I made a nice improvement to it today.\nHow it works The dotfiles are managed by a Python script. In broad strokes, the script will:\nread a TOML file locate the configured paths create symlinks, based on custom marker text in the filenames, for files in subdirectories under the configured paths1 If there’s a conflict (i.e. two configured paths provide the same symlink target location), the TOML file contains the resolution for it (i.e. specifies one of the paths as the “winner” for that file). If a resolution doesn’t exist, the script errors out.\nThis setup exists mainly to allow me to have work-only dotfiles managed in work’s VCS with all their corporate stuff while keeping them separate yet cooperative with my dotfiles managed publicly on GitHub.\nThe problem Now, this effectively means that my dotfiles manager is a Python script. It also has a bunch of dependencies (specifically, rich because I like colors and tomli because it should probably run on all supported Python versions).\nThis usually means that you need to create a virtual environment to run it. That’s gotten a bit tedious and fragile given how frequently I keep changing my Python installations (gotta keep up with the latest and greatest!).\nThe solution The implementation I figured out a way to ensure that the script can be run without needing to manage a virtual environment myself. Now, it can be run on any machine with a working curl, bash, python3 and the ability to download from https://github.com. It also gracefully triggers MacOS’ prompt for “Hey, do you want to install our developer tooling stuff?” (XCode Command Line Tools, via the python3 shim they install on a new Mac).\nThis is made possible by pipx, inline dependency metadata and Python’s zipapps. There are also a few shenanigans to make this script a valid Bash script and a valid Python script. A \"\"\"\"true serves as our little gem of polyglot magic to make that possible.\nHow it works: Bash Let me show you the script first, with Bash’s syntax highlighting:\n#!/usr/bin/env bash # # /// script # requires-python = \"\u003e=3.8\" # dependencies = [ # \"rich\", # \"tomli\", # ] # /// # \"\"\"\"true if [[ ! -f '/tmp/pipx-dotfiles.pyz' ]]; then echo \"Downloading pipx...\" curl --proto '=https' --tlsv1.2 -sSLf https://github.com/pypa/pipx/releases/latest/download/pipx.pyz -o /tmp/pipx-dotfiles.pyz fi python3 /tmp/pipx-dotfiles.pyz run \"$0\" -- \"$@\" exit \"\"\" import rich print(rich.__version__) From Bash’s perspective, this script has a bunch of comments, then a few commands, and then an exit.\nThe way Bash processes a script is by reading it as a buffer and executing it before moving on. This allows Bash scripts containing syntax issues to be run, as long as the syntax issue is somewhere that isn’t being read by Bash (i.e. after the point of exit). We’re definitely using that since the Python code (which is not valid Bash syntax) is present after the exit.\nTo Bash, our little gem of magic (\"\"\"\"true) is the same as a true command since it’s a bunch of empty strings concatenated together with true. And, true is used as a no-op command (it exits with code 0 and does nothing else).2 It is treated the same as a true on its own line and Bash proceeds with the rest of the logic as a regular Bash script.\nThe rest of the logic in the Bash script is to download pipx’s zipapp (if it’s not already downloaded) and then run the script itself with python3 run ","wordCount":"1095","inLanguage":"en","datePublished":"2024-05-31T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://pradyunsg.me/blog/2024/05/31/python-scripts-with-pipx-bash/"},"publisher":{"@type":"Organization","name":"Pradyun Gedam","logo":{"@type":"ImageObject","url":"https://pradyunsg.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pradyunsg.me/ accesskey=h title="Pradyun Gedam (Alt + H)">Pradyun Gedam</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pradyunsg.me/about/ title=about><span>about</span></a></li><li><a href=https://pradyunsg.me/blog/ title=Blog><span>blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Improving my dotfiles manager with pipx and inline dependency metadata</h1><div class=post-meta>May 31, 2024&nbsp;·&nbsp;6 minutes</div></header><div class=post-content><p>I have a (somewhat unnecessarily) custom setup for managing my dotfiles and I made a nice improvement to it today.</p><h2 id=how-it-works>How it works<a hidden class=anchor aria-hidden=true href=#how-it-works>#</a></h2><p>The dotfiles are managed by a Python script. In broad strokes, the script will:</p><ul><li>read a TOML file</li><li>locate the configured paths</li><li>create symlinks, based on custom marker text in the filenames, for files in subdirectories under the configured paths<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li></ul><p>If there&rsquo;s a conflict (i.e. two configured paths provide the same symlink target location), the TOML file contains the resolution for it (i.e. specifies one of the paths as the &ldquo;winner&rdquo; for that file). If a resolution doesn&rsquo;t exist, the script errors out.</p><p>This setup exists mainly to allow me to have work-only dotfiles managed in work&rsquo;s VCS with all their corporate stuff while keeping them separate yet cooperative with my dotfiles managed publicly on GitHub.</p><h2 id=the-problem>The problem<a hidden class=anchor aria-hidden=true href=#the-problem>#</a></h2><p>Now, this effectively means that my dotfiles manager is a Python script. It also has a bunch of dependencies (specifically, <code>rich</code> because I like colors and <code>tomli</code> because it should probably run on all supported Python versions).</p><p>This usually means that you need to create a virtual environment to run it. That&rsquo;s gotten a bit tedious and fragile given how frequently I keep changing my Python installations (gotta keep up with the latest and greatest!).</p><h2 id=the-solution>The solution<a hidden class=anchor aria-hidden=true href=#the-solution>#</a></h2><h3 id=the-implementation>The implementation<a hidden class=anchor aria-hidden=true href=#the-implementation>#</a></h3><p>I figured out a way to ensure that the script can be run without needing to manage a virtual environment myself. Now, it can be run on any machine with a working <code>curl</code>, <code>bash</code>, <code>python3</code> and the ability to download from <a href=https://github.com>https://github.com</a>. It also gracefully triggers MacOS&rsquo; prompt for &ldquo;Hey, do you want to install our developer tooling stuff?&rdquo; (XCode Command Line Tools, via the <code>python3</code> shim they install on a new Mac).</p><p>This is made possible by <code>pipx</code>, inline dependency metadata and Python&rsquo;s zipapps. There are also a few shenanigans to make this script a valid Bash script and a valid Python script. A <code>""""true</code> serves as our little gem of polyglot magic to make that possible.</p><h3 id=how-it-works-bash>How it works: Bash<a hidden class=anchor aria-hidden=true href=#how-it-works-bash>#</a></h3><p>Let me show you the script first, with Bash&rsquo;s syntax highlighting:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># /// script</span>
</span></span><span style=display:flex><span><span style=color:#75715e># requires-python = &#34;&gt;=3.8&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># dependencies = [</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   &#34;rich&#34;,</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   &#34;tomli&#34;,</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ///</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;&#34;</span>true
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> ! -f <span style=color:#e6db74>&#39;/tmp/pipx-dotfiles.pyz&#39;</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;Downloading pipx...&#34;</span>
</span></span><span style=display:flex><span>  curl --proto <span style=color:#e6db74>&#39;=https&#39;</span> --tlsv1.2 -sSLf https://github.com/pypa/pipx/releases/latest/download/pipx.pyz -o /tmp/pipx-dotfiles.pyz
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>python3 /tmp/pipx-dotfiles.pyz run <span style=color:#e6db74>&#34;</span>$0<span style=color:#e6db74>&#34;</span> -- <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>exit
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>import rich
</span></span></span><span style=display:flex><span><span style=color:#e6db74>print(rich.__version__)
</span></span></span></code></pre></div><p>From Bash&rsquo;s perspective, this script has a bunch of comments, then a few commands, and then an <code>exit</code>.</p><p>The way Bash processes a script is by reading it as a buffer and executing it before moving on. This allows Bash scripts containing syntax issues to be run, as long as the syntax issue is somewhere that isn&rsquo;t being read by Bash (i.e. after the point of exit). We&rsquo;re definitely using that since the Python code (which is not valid Bash syntax) is present after the <code>exit</code>.</p><p>To Bash, our little gem of magic (<code>""""true</code>) is the same as a <code>true</code> command since it&rsquo;s a bunch of empty strings concatenated together with <code>true</code>. And, <code>true</code> is used as a no-op command (it exits with code 0 and does nothing else).<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> It is treated the same as a <code>true</code> on its own line and Bash proceeds with the rest of the logic as a regular Bash script.</p><p>The rest of the logic in the Bash script is to download <code>pipx</code>&rsquo;s zipapp (if it&rsquo;s not already downloaded) and then run the script itself with <code>python3 &lt;pipx-zipapp> run &lt;script> -- &lt;any arguments passed to the script></code>.</p><h3 id=how-it-works-zipapp>How it works: zipapp<a hidden class=anchor aria-hidden=true href=#how-it-works-zipapp>#</a></h3><p>Wait, a zipapp?</p><p>So, that&rsquo;s a fun Python feature: it can execute a zip file as if it were a script. Python will look for a <code>__main__.py</code> in the zip file and, if it&rsquo;s there, the <code>__main__.py</code> as if it were a script. See <a href=https://docs.python.org/3/library/zipapp.html>the documentation</a> if you want to learn more about this.</p><p>In this case, the <code>pipx</code> maintainers create a maintain a zipapp and attach it to their GitHub releases. By using GitHub&rsquo;s <code>latest</code> release URL, we can fetch the zipapp for the latest release (with a redirect, hence the <code>-L</code> to <code>curl</code>) without much additional complexity.</p><h3 id=how-it-works-pipx-run>How it works: pipx run<a hidden class=anchor aria-hidden=true href=#how-it-works-pipx-run>#</a></h3><p><code>pipx run</code> enables running a script with the dependencies being installed by <code>pipx</code> in a cached virtual environment that is managed by <code>pipx</code>.</p><p>Notably, it supports <a href=https://peps.python.org/pep-0723/>PEP 723</a> (inline script metadata) which enables declaring dependency information inline. This is what the <code>/// script</code> and <code>///</code> are serving as markers for. The <code>requires-python</code> and <code>dependencies</code> are bits of metadata that <code>pipx</code> will use to determine what needs to be present for running the script.</p><p>Assuming you&rsquo;re on a compatible Python, <code>pipx</code> will parse that chunk, install the dependencies in a cached virtual environment and then run the script within that virtual environment. This means that the dependencies are installed by <code>pipx</code> and can/will be reused across multiple runs of the script by <code>pipx</code>.</p><h3 id=how-it-works-python>How it works: Python<a hidden class=anchor aria-hidden=true href=#how-it-works-python>#</a></h3><p>Let&rsquo;s look at the script again, this time with Python&rsquo;s syntax highlighting:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env bash</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># /// script</span>
</span></span><span style=display:flex><span><span style=color:#75715e># requires-python = &#34;&gt;=3.8&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># dependencies = [</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   &#34;rich&#34;,</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   &#34;tomli&#34;,</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ///</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;&#34;true
</span></span></span><span style=display:flex><span><span style=color:#e6db74>if [[ ! -f &#39;/tmp/pipx-dotfiles.pyz&#39; ]]; then
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  echo &#34;Downloading pipx...&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  curl --proto &#39;=https&#39; --tlsv1.2 -sSLf https://github.com/pypa/pipx/releases/latest/download/pipx.pyz -o /tmp/pipx-dotfiles.pyz
</span></span></span><span style=display:flex><span><span style=color:#e6db74>fi
</span></span></span><span style=display:flex><span><span style=color:#e6db74>python3 /tmp/pipx-dotfiles.pyz run &#34;$0&#34; -- &#34;$@&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>exit
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> rich
</span></span><span style=display:flex><span>print(rich<span style=color:#f92672>.</span>__version__)
</span></span></code></pre></div><p>From Python&rsquo;s perspective, this script has a bunch of comments, then a docstring, and then the whole Python script.</p><p>To Python, our little gem of magic (<code>""""true</code>) is the start of a multiline string which starts with the content <code>"true\n</code>. This is valid Python syntax, and Python will happily treat it as the start of the string literal. The end of the string literal is the next <code>"""</code> it encounters, which is the one at the end of the Bash parts of the script.</p><p>This means that the Bash script is treated as a multiline string by Python. It&rsquo;s treated as the docstring of the Python script. I am not too concerned about that since this is a script that doesn&rsquo;t need a docstring.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><code>symlink</code> with periods around it based on where in the file it shows up&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>It is possible to put almost any valid Bash syntax after the 4 double quotes (like, you can start an <code>if</code> statement, or something else) as long as you don&rsquo;t have whitespace between the 4th double quote and the keyword/CLI tool name. I just didn&rsquo;t like how that stuff looked so I went with <code>true</code> on that line.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://pradyunsg.me/tags/python/>Python</a></li><li><a href=https://pradyunsg.me/tags/dotfiles/>dotfiles</a></li></ul><nav class=paginav><a class=next href=https://pradyunsg.me/blog/2024/05/13/pip-24-1-betas/><span class=title>Older »</span><br><span>pip 24.1 betas -- help us test a major upcoming change!</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://pradyunsg.me/>Pradyun Gedam</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
with tweaks.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>