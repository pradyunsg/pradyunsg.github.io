<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>pip on Pradyun Gedam</title><link>https://pradyunsg.me/tags/pip/</link><description>Recent content in pip on Pradyun Gedam</description><generator>Hugo -- 0.122.0</generator><language>en</language><lastBuildDate>Mon, 01 Jan 0001 00:00:00 +0000</lastBuildDate><atom:link href="https://pradyunsg.me/tags/pip/index.xml" rel="self" type="application/rss+xml"/><item><title>pip 24.1 betas -- help us test a major upcoming change!</title><link>https://pradyunsg.me/blog/2024/05/13/pip-24-1-betas/</link><pubDate>Mon, 13 May 2024 00:00:00 +0000</pubDate><guid>https://pradyunsg.me/blog/2024/05/13/pip-24-1-betas/</guid><description>The pip team has released pip 24.1b1 which contains a lot of significant improvements and bug fixes.
I&amp;rsquo;d like to highlight a major change in this blog post: the removal of support for &amp;ldquo;legacy&amp;rdquo; versions and dependency specification, or as I like to call it, nonsensical versions and dependencies. We&amp;rsquo;re releasing this as a beta to get feedback from the community on how this change affects their workflows.
Nonsensical versions and dependencies For a bunch of historical reasons, pip has allowed many arbitrary strings as versions and dependency specification.</description><content:encoded><![CDATA[<p>The pip team has released <a href="https://pypi.org/project/pip/24.1b1/">pip 24.1b1</a> which contains a <a href="https://pip.pypa.io/en/latest/news/#b1-2024-05-06">lot of significant improvements and bug fixes</a>.</p>
<p>I&rsquo;d like to highlight a major change in this blog post: the removal of support for &ldquo;legacy&rdquo; versions and dependency specification, or as I like to call it, nonsensical versions and dependencies. We&rsquo;re releasing this as a beta to get feedback from the community on how this change affects their workflows.</p>
<h2 id="nonsensical-versions-and-dependencies">Nonsensical versions and dependencies</h2>
<p>For a bunch of historical reasons, pip has allowed many arbitrary strings as versions and dependency specification. There&rsquo;s so many kinds of bad behaviours that this &ldquo;feature&rdquo; has enabled.</p>
<p>My favourite example is <a href="https://github.com/pypa/packaging/issues/530">one I wrote back in 2022</a> on the <code>packaging</code><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> project&rsquo;s issue tracker:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> packaging<span style="color:#f92672">.</span>version<span style="color:#f92672">.</span>parse(<span style="color:#e6db74">&#34;This is a completely random string&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>LegacyVersion(<span style="color:#e6db74">&#39;This is a completely random string&#39;</span>)<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>Or providing weird version comparisons:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> packaging<span style="color:#f92672">.</span>version<span style="color:#f92672">.</span>parse(<span style="color:#e6db74">&#34;1.0&#34;</span>) <span style="color:#f92672">&gt;</span> packaging<span style="color:#f92672">.</span>version<span style="color:#f92672">.</span>parse(<span style="color:#e6db74">&#34;99999.0.whatever&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> packaging<span style="color:#f92672">.</span>version<span style="color:#f92672">.</span>parse(<span style="color:#e6db74">&#34;1.0&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>Version(<span style="color:#e6db74">&#39;1.0&#39;</span>)<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> packaging<span style="color:#f92672">.</span>version<span style="color:#f92672">.</span>parse(<span style="color:#e6db74">&#34;99999.0.whatever&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>LegacyVersion(<span style="color:#e6db74">&#39;99999.0.whatever&#39;</span>)<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>Or hiding mistakes in dependency declarations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> all_dependencies <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     <span style="color:#e6db74">&#34;package == 1&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     <span style="color:#e6db74">&#34;another-package&#34;</span>,
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>     <span style="color:#e6db74">&#34;yet-another-package&#34;</span>,
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> [packaging<span style="color:#f92672">.</span>requirements<span style="color:#f92672">.</span>Requirement(s) <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> all_dependencies]
</span></span><span style="display:flex;"><span>[<span style="color:#f92672">&lt;</span>Requirement(<span style="color:#e6db74">&#39;package==1another-package&#39;</span>)<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Requirement(<span style="color:#e6db74">&#39;yet-another-package&#39;</span>)<span style="color:#f92672">&gt;</span>]
</span></span></code></pre></div><p>Over a decade ago, the Python packaging ecosystem adopted <a href="https://peps.python.org/pep-0440/">PEP 440</a> which defined a standard for versions and dependency specification. While this standard has been adopted by basically every single tool in the ecosystem, support for &ldquo;legacy&rdquo; versions and requirements has been maintained even though it has caused a lot of user confusion and bugs in the Python ecosystem.</p>
<h2 id="getting-rid-of-the-nonsense">Getting rid of the nonsense</h2>
<p>Over the course of the last decade, across multiple projects in the Python packaging ecosystem, many PyPA projects have been working to make this behaviour not possible. The package index, <a href="https://pypi.org">https://pypi.org</a>, has not accepted uploads with bad versions for many years now and is also enforcing validity of the requirements on all uploads. The tooling that generate packages (build-backends) also now refuse to generate packages with such bad metadata in them.</p>
<p>This effort has been undertaken by many people across the Python packaging ecosystem, and I&rsquo;m very grateful for all the work that has gone into this. It regularly surprises me how much work goes into making sure that the foundational pieces of Python&rsquo;s packaging ecosystem are improving, even absent any institutional investment into it.</p>
<p>This pip release marks the next major step in the direction of improving behaviours in this area: updating the package installer to stop accepting such packages. Starting with this pip release, pip will refuse to install packages with bad versions or dependency specification and will ignore any files with such bad versions or dependency specification during the dependency resolution step.</p>
<h2 id="where-we-cant-see-the-nonsense">Where we can&rsquo;t see the nonsense</h2>
<p>While a substantial amount of effort has been put into making sure pip can work correctly when enforcing correctness around these versions and dependency specification, we want to be cautious in rolling out this change. There are many places that Python is used where we can&rsquo;t access the packages (e.g. private package indexes hosting proprietary code), and thus can&rsquo;t ensure that packages have appropriate metadata in those spaces.</p>
<p>We&rsquo;re releasing this as a beta to get feedback from the community on any issues that might arise from this change. This will help us better understand how this change affects user workflows and what actionable guidance can be provided to users in various contexts.</p>
<h2 id="help-us-test-the-changes">Help us test the changes</h2>
<p>We&rsquo;re looking for feedback from Python users on this beta release. Notably, we&rsquo;d like for users who are using package indexes other than PyPI to test their workflows against this beta release of pip and provide us with feedback.</p>
<p>You can let us know about issues related to this change on pip&rsquo;s issue tracker (please check for duplicates before filing, and use reactions rather than saying &ldquo;me too&rdquo;!). Please also feel welcome to tell us about the good stuff, like if this release made dependency resolves quicker &ndash; we like hearing about that too! :)</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>While there&rsquo;s a lot of people who have worked on things I mentioned in this blog post, I can&rsquo;t really list them all here &ndash; you know who you are, and thank you for all the work you&rsquo;ve done toward this as well as the other cool things you&rsquo;ve worked on.</p>
<p>I do want to thank Paul Moore, Stéphane Bidoul, Richard Si and Pavithra Eswaramoorthy for reviewing various drafts of this post and providing feedback on it.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Listen, software engineers are great at naming things. This is obviously the Python package providing shared common implementations of Python packaging standards for Python packaging tools. And, yes, it&rsquo;s hosted on the Python package index.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>Testing the next-gen pip dependency resolver</title><link>https://pradyunsg.me/blog/2020/03/27/pip-resolver-testing/</link><pubDate>Fri, 27 Mar 2020 00:00:00 +0000</pubDate><guid>https://pradyunsg.me/blog/2020/03/27/pip-resolver-testing/</guid><description>This is an attempt to summarize the broader software architecture around dependency resolution in pip and how testing is being done around this area.
The motivation behind writing this, is to make sure all the developers working on this project are on the same page, and to have a written record about the state of affairs.
Architecture The &amp;ldquo;legacy&amp;rdquo; resolver in pip, is implemented as part of pip&amp;rsquo;s codebase and has been a part of it for many years.</description><content:encoded><![CDATA[<p>This is an attempt to summarize the broader software architecture around dependency resolution in pip and how testing is being done around this area.</p>
<p>The motivation behind writing this, is to make sure all the developers working on this project are on the same page, and to have a written record about the state of affairs.</p>
<h2 id="architecture">Architecture</h2>
<p>The &ldquo;legacy&rdquo; resolver in pip, is implemented as part of pip&rsquo;s codebase and has been a part of it for many years. It&rsquo;s very tightly coupled with the existing code, isn&rsquo;t easy to work with and has severe backward compatibility concerns with modifying directly &ndash; which is why we&rsquo;re implementing a separate &ldquo;new&rdquo; resolver in this project, instead of trying to improve the existing one.</p>
<p>The &ldquo;new&rdquo; resolver that is under development, is not implemented as part of pip&rsquo;s codebase; not completely anyway. We&rsquo;re using an abstraction that separates all the metadata-generation-and-handling stuff vs the core algorithm. This allows us to work on the core algorithm logic (i.e. the NP-hard search problem) separately from pip-specific logic (eg. download, building etc). The abstraction and core algorithm are written/maintained in <a href="https://github.com/sarugaku/resolvelib">https://github.com/sarugaku/resolvelib</a> right now. The pip-specific logic for implementing the &ldquo;other side&rdquo; of the abstraction is in <a href="https://github.com/pypa/pip/tree/master/src/pip/_internal/resolution/resolvelib">https://github.com/pypa/pip/tree/master/src/pip/_internal/resolution/resolvelib</a>.</p>
<h2 id="testing">Testing</h2>
<p>In terms of testing, we have dependency-resolution-related tests in both resolvelib and pip.</p>
<h3 id="resolvelib">resolvelib</h3>
<p>The tests in resolvelib are intended more as &ldquo;check if the algorithm does things correctly&rdquo; and even contains tests that are agnostic to the Python ecosystem (eg. we&rsquo;ve borrowed tests from Ruby, Swift etc). The goal here is to make sure that the core algorithm we implement is capable of generating correct answers (for example: not getting stuck in looping on the same &ldquo;requirement&rdquo;, not revisiting rejected nodes etc).</p>
<h3 id="pip">pip</h3>
<p>The tests in pip is where I&rsquo;ll start needing more words to explain what&rsquo;s happening. :)</p>
<h4 id="yaml-based-tests">YAML-based tests</h4>
<p>We have &ldquo;YAML&rdquo; tests which I&rsquo;d written back in 2017, as a format to easily write tests for pip&rsquo;s new resolver when we implement it. However, since we didn&rsquo;t have a need for it to be working completely back then (there wasn&rsquo;t a new resolver to test with it!), the &ldquo;harness&rdquo; for running these tests isn&rsquo;t complete and would likely need some work to be as feature complete as we&rsquo;d want it to be, for writing good tests.</p>
<p>YAML tests: <a href="https://github.com/pypa/pip/tree/master/tests/yaml">https://github.com/pypa/pip/tree/master/tests/yaml</a><br>
YAML test &ldquo;harness&rdquo;: <a href="https://github.com/pypa/pip/blob/master/tests/functional/test_yaml.py">https://github.com/pypa/pip/blob/master/tests/functional/test_yaml.py</a> and <a href="https://github.com/pypa/pip/blob/master/tests/lib/yaml_helpers.py">https://github.com/pypa/pip/blob/master/tests/lib/yaml_helpers.py</a></p>
<h4 id="new-resolver-tests">&ldquo;new&rdquo; resolver tests</h4>
<h5 id="unit-tests">unit tests</h5>
<p>We have some unit tests for the new resolver implementation. These cover very basic &ldquo;sanity checks&rdquo; to ensure it follows the &ldquo;contract&rdquo; of the abstraction, like &ldquo;do the candidates returned by a requirement actually satisfy that requirement?&rdquo;. These likely don&rsquo;t need to be touched, since they&rsquo;re fairly well scoped and test fairly low-level details (i.e. ideal for unit tests).</p>
<p>New resolver unit tests: <a href="https://github.com/pypa/pip/tree/master/tests/unit/resolution_resolvelib">https://github.com/pypa/pip/tree/master/tests/unit/resolution_resolvelib</a></p>
<h5 id="functional-tests">functional tests</h5>
<p>We also have &ldquo;new resolver functional tests&rdquo;, which are written as part of the current work. These exist since how-to-work-with-YAML-tests was not an easy question to answer and there needs to be work done (both on the YAML format, as well as the YAML test harness) to flag which tests should run with which resolver (both, only legacy, only new) and make it possible to put run these tests in CI easily.</p>
<p>New resolver functional tests: <a href="https://github.com/pypa/pip/blob/master/tests/functional/test_new_resolver.py">https://github.com/pypa/pip/blob/master/tests/functional/test_new_resolver.py</a></p>
<h4 id="test_installpy">test_install*.py</h4>
<p>These files test all the functionality of the install command (like: does it use the right build dependencies, does it download the correct files, does it write the correct metadata etc). There might be some dependency-resolution-related tests in <code>test_install*.py</code> files.</p>
<p>These files contain a lot of tests so, ideally, at some point, someone would go through and de-duplicate tests from this as well.</p>
<h2 id="how-can-you-help">How can you help?</h2>
<p>If you use pip, there are a multiple ways that you can help us!</p>
<ul>
<li>
<p>First and most fundamentally, <a href="https://bit.ly/pip-ux-studies">please help us understand how you use pip by <strong>talking with our user experience researchers</strong></a>. You can do this right now! You can take a survey, or have a researcher interview you over a video call. <a href="https://bit.ly/pip-ux-studies">Please sign up and spread the word</a> to anyone who uses pip (even a little bit).</p>
</li>
<li>
<p>Right now, even before we release the new resolver as a beta, you can help by <strong>running <code>pip check</code> on your current environment</strong>. This will report if you have any inconsistencies in your set of installed packages. Having a clean installation will make it much less likely that you will hit issues when the new resolver is released (and may address hidden problems in your current environment!). If you run <code>pip check</code> and run into stuff you can’t figure out, please <a href="https://pip.pypa.io/">ask for help in our issue tracker or chat</a>.</p>
</li>
</ul>
<hr>
<p>Thanks to Paul Moore and Tzu-Ping for help in reviewing and writing this post,
as well as Sumana Harihareswara for suggesting to put this up on my blog!</p>
]]></content:encoded></item></channel></rss>